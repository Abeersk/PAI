{
  "permissions": {
    "allow": [
      "Bash(python -c \"\nimport numpy as np\n\ndef inverse_kinematics_2dof_planar(x, y, L1, L2):\n    ''''''Correct analytical IK for 2DOF planar arm''''''\n    r = np.sqrt(x**2 + y**2)\n    \n    # Check reachability\n    if r > L1 + L2:\n        return None, None  # Beyond reach\n    if r < abs(L1 - L2):\n        return None, None  # Inside inner workspace\n    \n    # Calculate theta2 using law of cosines\n    cos_theta2 = (L1**2 + L2**2 - r**2) / (2 * L1 * L2)\n    cos_theta2 = np.clip(cos_theta2, -1.0, 1.0)  # Handle numerical errors\n    theta2 = np.arccos(cos_theta2)\n    \n    # Calculate theta1 for first solution (elbow up)\n    k1 = L1 + L2 * np.cos(theta2)\n    k2 = L2 * np.sin(theta2)\n    theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)\n    \n    # Calculate theta1 for second solution (elbow down)\n    theta2_alt = -theta2\n    k1_alt = L1 + L2 * np.cos(theta2_alt)\n    k2_alt = L2 * np.sin(theta2_alt)\n    theta1_alt = np.arctan2(y, x) - np.arctan2(k2_alt, k1_alt)\n    \n    return (theta1, theta2), (theta1_alt, theta2_alt)\n\n# Test with our problematic case\nL1, L2 = 1.0, 0.8\nx, y = 1.2, 0.5\n\nsol1, sol2 = inverse_kinematics_2dof_planar(x, y, L1, L2)\nprint(''My implementation - Solutions:'', sol1, sol2)\n\nif sol1 and sol2:\n    t1, t2 = sol1\n    t1_alt, t2_alt = sol2\n    \n    # Verify with planar kinematics (not DH)\n    x1 = L1*np.cos(t1) + L2*np.cos(t1 + t2)\n    y1 = L1*np.sin(t1) + L2*np.sin(t1 + t2)\n    print(''Solution 1 verification:'', x1, y1, ''error:'', x1-x, y1-y)\n    \n    x2 = L1*np.cos(t1_alt) + L2*np.cos(t1_alt + t2_alt)\n    y2 = L1*np.sin(t1_alt) + L2*np.sin(t1_alt + t2_alt)\n    print(''Solution 2 verification:'', x2, y2, ''error:'', x2-x, y2-y)\n    \n    print(''Target:'', x, y)\n\")",
      "Bash(python -c \"\nimport numpy as np\nfrom code.ch04_kinematics.inverse_kinematics import inverse_kinematics_analytical_2dof\n\n# Test the specific values case\nL1, L2 = 1.0, 1.0\nx, y = np.sqrt(2)/2, np.sqrt(2)/2  # 45-degree position\n\nprint(f''Target: x={x}, y={y}'')\nprint(f''Distance: {np.sqrt(x**2 + y**2)}, should be 1 for L1=L2=1 at 45 degrees? {np.sqrt(x**2 + y**2)}'')\nprint(f''Wait, distance to (sqrt(2)/2, sqrt(2)/2) is sqrt(1/2 + 1/2) = sqrt(1) = 1'')\nprint(f''For a 2R arm with L1=1, L2=1, reaching distance 1 is definitely possible'')\n\nsol1, sol2 = inverse_kinematics_analytical_2dof(x, y, L1, L2)\nprint(f''Solutions: sol1={sol1}, sol2={sol2}'')\n\nif sol1:\n    theta1, theta2 = sol1\n    print(f''Solution 1: theta1={theta1}, theta2={theta2}'')\n    print(f''Theta1 in degrees: {np.degrees(theta1)}'')\n    print(f''Theta2 in degrees: {np.degrees(theta2)}'')\n    \n    # Verify\n    x_check = L1*np.cos(theta1) + L2*np.cos(theta1 + theta2)\n    y_check = L1*np.sin(theta1) + L2*np.sin(theta1 + theta2)\n    print(f''Verification: ({x_check:.10f}, {y_check:.10f}) vs target ({x:.10f}, {y:.10f})'')\n    print(f''Error: ({x_check-x:.10f}, {y_check-y:.10f})'')\n\n# The test comment says ''For a 2-DOF arm with L1=1, L2=1, at target (sqrt(2), sqrt(2))''\n# But the code uses (sqrt(2)/2, sqrt(2)/2). Let me check the original target:\nprint(f''\\nNote: The comment mentions (sqrt(2), sqrt(2)) but code uses (sqrt(2)/2, sqrt(2)/2)'')\nprint(f''distance to (sqrt(2), sqrt(2)) would be sqrt(2+2) = 2, max reach is 1+1=2, so that would be at workspace boundary'')\nprint(f''distance to (sqrt(2)/2, sqrt(2)/2) is 1, which is reachable'')\n\")",
      "Bash(python -c \"\nimport numpy as np\nfrom code.ch04_kinematics.inverse_kinematics import inverse_kinematics_analytical_2dof\n\n# Test with the target mentioned in the comment: (sqrt(2), sqrt(2))\nL1, L2 = 1.0, 1.0\nx, y = np.sqrt(2), np.sqrt(2)  # As mentioned in the comment\n\nprint(f''Testing target from comment: x={x}, y={y}'')\nprint(f''Distance: {np.sqrt(x**2 + y**2)} (should be 2 for max reach with L1=L2=1: {L1+L2})'')\n\nsol1, sol2 = inverse_kinematics_analytical_2dof(x, y, L1, L2)\nprint(f''Solutions for (sqrt(2), sqrt(2)): sol1={sol1}, sol2={sol2}'')\n\nif sol1:\n    theta1, theta2 = sol1\n    print(f''Solution 1: theta1={theta1}, theta2={theta2}'')\n    print(f''Theta1 in degrees: {np.degrees(theta1)}'')\n    print(f''Theta2 in degrees: {np.degrees(theta2)}'')\n    \n    # Verify\n    x_check = L1*np.cos(theta1) + L2*np.cos(theta1 + theta2)\n    y_check = L1*np.sin(theta1) + L2*np.sin(theta1 + theta2)\n    print(f''Verification: ({x_check:.10f}, {y_check:.10f}) vs target ({x:.10f}, {y:.10f})'')\n    print(f''Error: ({x_check-x:.10f}, {y_check-y:.10f})'')\n\nprint(f''\\nActual test uses: x={np.sqrt(2)/2}, y={np.sqrt(2)/2}'')\nprint(f''Distance for actual test: {np.sqrt((np.sqrt(2)/2)**2 + (np.sqrt(2)/2)**2)} = {np.sqrt(0.5 + 0.5)} = 1'')\n\")"
    ],
    "deny": [],
    "ask": []
  }
}
